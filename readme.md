# Бэкенд часть приложения облачного хранилища файлов "MyFiles" + Framework

## Введение
Данное приложение выполненно на кастомном фреймворке при использовании минимального количества библиотек. В первой части данной документации будет изложен процесс взаимодействия с фреймворком для возможности расширение данного приложение и написания новых приложений, вторая часть данной документации будет о возможностях данного приложения.

## Часть 1 -  Framework
### Навигация
Данный фреймоворк я постарался сделать максимально простым и  при этом, чтобы базовый вещи вроде роутинга или раздачи статических файлов через мидлверы работали из коробки. Грубо говоря, чтобы была возможность поставить данный фреймворк и сразу раздавать html, json и php и был максимально наглядным. Получилось что-то между express.js и laravel.

Все запросы в фреймворк попадают в файл index.php - точка входа. Все статические файлы требуемые хранятся в директории public. В целом редактирования index.php в корне не требуется, он сама подтягивает все нужные библиотеки и файлы для работы приложения.


Для написания роутов, следует создавать файлы в папке routers, можно сделать таких файлов не ограниченное количество. В папке pages хранятся html файлы и php скрипты, который можно отдать в ответ на запрос. В папке sessions хранятся файлы сессии, изменить место для хранения сесссий можно в .env файле (не рекомендуется)

В папке storage хранятся файлы для логирования, по умолчанию есть только файл error.log, туда пишутся все ошибки, однако можно создать свои лог файлы и писать ошибки туда для удобства их чтения.

### Конфигурация

Я не люблю копаться в php.ini, поэтому я постарался все нужные, и самые часто используемые [настройки](https://www.php.net/manual/ru/ini.core.php "настройки") переопределить в приложении и вынести в env файл и .htaccess файл:

| Название конфигурации  | Где редактируется  |
| ------------- | ------------- |
|  memory_limit   |  .htaccess  |
| post_max_size   | .htaccess  |
| upload_max_filesize | .htaccess  |
|session.save_path| .env (параметр - SESSION_SAVE_PATH)  |
|session.gc_maxlifetime| .env (параметр - SESSION_TIME)  |
| session.cookie_lifetime| .env (параметр - COOCKIE_TIME)  |
|  log_errors | .env (параметр - PHP_ERROR_LOG)  |
|  error_log | .env (параметр - ERROR_LOG_PATH)  |

### Встроенные классы

#### Router

Данный класс отвечает за роутинг, все методы статичные. Чтобы отработать запрос, нужно вызвать метод с соответствующий названию метода http запроса (для get это get, для post это post и так далее).
Метод аргументами принимает:

1. Путь запроса - пути важно писать в строго формате начиная со слэша /test/path а не path/test, также в конце пути слэш ставить не нужно. В случае если хотите написать какие то изменяемые переменный в пути указывать их нужно в {}
пример пути:  /api/user/{id}

2. Объект контроллера (может быть вызывано несколько мидлверов перед вызовом контроллера)

3. Метод контроллера, который нужно вызвать (в случае если есть мидлверы), после прохождения мидлверов

#### Controller

Данный класс может выполнять как функцию обработки http запроса, так и мидвера. В любом случае для первого и для второго случая вы должны создать класс унаследованный от этого класса (желательно в папке src/app/Controllers, мидверы же желательно сохранять в папке src/app/Controllers/Middlewares), далее если вы хотите чтобы он просто обрабатывал запрос, просто напишите метод с любым названием и напишите что вы хотите там сделать, во втором случае, вам следует переписать функцию handle, там можете провести валидацию данных или просто какие-то действия логику которых вы хотите отделать от обработки основного запроса. В случае если вы хотите вызвать следующий контроллер нужно вызвать метод:
```
$this->nextController($req, $method);
```
Первый аргумент это объект класса Request (о котором будет ниже), вторым метод запроса. Количество элементов в цепочке мидлвэров никак не ограниченно, чтобы в ответ на запроса, он прошел данную цепочку, нужно в объекте контроллера вызвать метод **next** и в него передать новый контроллер, в котором также можно вызвать метод **next** в последнем контроллере данной цепочки Router вызовет метод который вы в него прописали 3 аргументом. Наглядный пример ниже:
```
Router::get(
    '/api/user/{id}',
    Auth::create()->next(ValidID::create()->next(User::create())),
    'index'
);
```
В функции handle если мы считаем, что в следующий контроллер не нужно передавать ответ, просто не вызываем ```$this->nextController($req, $method);``` и можем ответить на запрос прямо в методе handle.

####  Request

Объект данного класса Router передает контроллерам, в качестве аргумента. Ниже прописанный метода класса, которые позволят получить информацию о запросе.

| Название метода  | Что делает  | 
| -------------- | ------------- |
| ```getParam(string $paramName);``` | Получает параментр запроса по ключу   paramName |
| ```getArg(string $argName);``` | Получает аргумент запроса по ключу   argName, под аргументом понимается некоторая изменяемый в {} параментр, например если у нас путь /api/user/{id}, то достать id можно так ```$req->getArg('id') ``` |
| ``` setInProps(string $key, mixed $value)``` |  Чтобы из одного мидлвэра передать значение в следующий контроллер мы можем положить это значение в параметр $value данного метода и оно будет доступно по ключу $key  |
| ``` getProps(string $key)``` |  Достать это значение мы этим методом , указав ключ по которому стоит его забрать  |
| ```getFile(string $key)``` |  Достать файл , а точнее массив который имеет название файла, путь во временном хранилище, можно этим методом. NB:  если вы хотите отправить файл на сервер выбирайте формат form-data и только метод POST |

####  Response

Объект вызывается  в первую очередь в контроллерах  для работы с сессиями и возможности ответа сервера, и служит некоторым наглядным фасадом для выполнения встроенный в php действий для ответа. Также важно отметить, если вы хотите , чтобы у вас был некоторый ответ по умолчанию, скажем если ни один контроллер не пройден, то вы можете просто прописать в последнем файле роутинга некоторый ответ скажем некоторый json, php скрипт или html (в моем тестовом приложение это можно наглядно увидеть в файле web.php)

Если вы хотите кастомный ответ , если произошла ошибка на сервере, то стоит зайти в файл index.php в корне проекта (редкий случай когда это нужно) и  добавить тот ответ, который вы хотите в функцию ```exception_handler```

| Название метода  | Что делает  | 
| -------------- | ------------- |
| ```json(array $arrayToJson, $code = 200)``` | Отдает некоторый json файл преобразуя его из массива, вторым аргументом по умолчанию отдает 200 код ответа, но вы можете указать какой то другой, скажем 400 или 500 в случае ошибки |
| ```end($code = 200)``` | Данный метод ничего не отдает, а просто прекращает действие скрипта и отдает некоторый код выполнения запроса, аналогично методу json |
| ```  setSession($sessionValues)``` |  Принимает массив  ключ->значение в сессию, пример : ``` Response::setSession(['id' => $newUserId, ]); ```|
| ``` getSession($key)``` | Получает значение сессии по ключу пример : ``` Response::getSession('id' ); ``` |
| ``` deleteSession()``` | Удаляет сессию |
| ```html(string $title, $code = 200)``` | Отдает html файл, из папки pages/html, первым аргументом принимает значение файла (без расширения), вторым код ответа |
| ```php(string $title, $vars = [], $code = 200)``` | Отдает php файл (в котором может быть сгенерирован html , например, или все что вы хотите) , из папки pages/php первым аргументом принимает значение файла (без расширения),вторым - переменны для php скрипта, которые будут доступны в скрипте в массиве - $_VARS,  третьим код ответа |
| ```upload(string $path, $name = null)``` | Отдает файл для скачивания на клиенте, первым аргументом принимает путь до файла, вторым, название, которое увидят на клиенте |

####  Logger
Имеет всего 1 метод - **printLog **, которым пишет аргументы в указаный лог файл (путь до лог файла определяется в .env)
Пример:
```
Logger::printLog(
		$e->getMessage(), 
		'db',
		true
);
```
Первый аргумент это текст лога (перенос строки, метод выполнит сам), второй название файла (.log, метод поставит сам поставит сам), данный мы записываем в в файл db.log , третий опциональный параметр, нужно ли ставить дату перед логом:
Вывод метода выше в лог файл следующее:
> Mon, 08 May 23 10:50:12 +0000 SQLSTATE[23000]: Integrity constraint violation: 1052 Column 'id' in where clause is ambiguous 

Logger вывел текст ошибки которую выдал mysql

#### Другие общие положения
В целом кастомный классы и файлы созданный вами вы можете хранить где угодно (кроме папки public, если конечно не хотите чтобы, клиент имел к ним доступ), однако я рекомендую хранить все это в папке src/app/Custom (как собственно я и делаю в приложение для хранения файлов)
Если вы хотите переопределить какие то настройки php.ini, которые не выполняются и о которых я писал выше, можно вызвать функцию [ini_set](https://www.php.net/manual/ru/function.ini-set.php "ini_set")  с необходимыми вам параметрами в файле** src/app/Config/ini.php**

#### Требования для работы приложения и фреймворка и начало работы
* После установки вам надо открыть для записи папку /storage рекурсивно.
* Для запуска приложения  нужно, чтобы в системе стоял веб-сервер - Apache
* PHP >= 8.0
 ##### Начало работы
1. Скачайте/клонируйте данный репозиторий
2. Установите необходимые библиотеки для работы  командой в вашей консоли 
```
composer install
```
3. Направьте ваш веб сервер Apache слушать какой то адрес , создав в папке sites-available файл конфига и сделав ссылку на него в папке sites-enabled и отправьте все запросы в проект.
**Пример файла:**
```html
<VirtualHost *:4321>
        ServerAdmin webmaster@localhost
        DocumentRoot /path/to/project/myfiles_service

        ErrorLog /some/path/error.log
        CustomLog /some/path//access.log combined

	<Directory  /path/to/project/myfiles_service>
		AllowOverride All
		Require all granted
	</Directory>
</VirtualHost>
```
Подробно как поднять Apache на вашем локальном или удаленном сервере можно в этой [**статье**](https://www.digitalocean.com/community/tutorials/linux-apache-mysql-php-lamp-ubuntu-18-04-ru#1-apache "статье")  (Также в этой статье можно подробно прочитать как в целом установить пакет LAMP, в который входит также  база данных, которая вам наверняка потребуется для работы , ну и php (само собой))
4. Далее можете удалить все пути в файлах в папке routers и все контроллеры и написать то что нужно вам, удачи!
5. Если вам все таки интересно простетировать приложение, то прочитайте следующую часть данной документации

## Часть 2 -  Приложение

Само приложение позволяет хранить файлы на удаленном сервере с возможностью регистрации и авторизации, многие методы валидации и авторизации сделаны довольно примитивно, но основной целью написания приложение было все таки показать возможность работы фреймворка. 
Ниже будут описаны ендпоинты, дергая за  данные "ручки" посредством http запросов  вы можете взаимодействовать с приложением:

| Путь  | Метод запроса  | Что делает | Нужна ли авторизация | Нужны ли права администратора | Комментарий |Пример ответа | параметры запроса (если есть) |
| ------------- | ------------- | ------------- |------------- | ------------- | ------------ | ------------- | ------------ |
| /api/user/{id} | GET | Отправляет JSON файл с инфорцией о пользователе| да | нет| вы можете получить данные только о себе, поэтому {id} должен в запросе должен быть как у вас, если вы хотите получить данные о другом пользователе, вам нужно авторизироваться как как admin |[{"id":1, "login":qwer@qwer.ru, "role":"user", "root_directory_id":2}] |- |
| /api/user | POST | Регистрация пользователя  | нет | нет| Во время регистрации вам также создается корневая директория, в которой вы можете создавать другие директори или файлы  |[{"id":1, "login":qwer@qwer.ru, "role":"user", "root_directory_id":2}] | **login** - какой то email, **password** - пароль, **role** - user или  admin |
| /api/user | PUT | Регистрация пользователя  | да | нет| Аналогично вы можете обновить только данные только о себе, если вы не админ,   |{"updated": true}| **login** - какой то email, **password** - пароль, **role** - user или  admin, **id** - пользователя которого вы обновляете  |
| /api/user/{id} | DELETE | Удаление пользователя  | да | нет| Аналогично вы можете удалить  только  себя, если вы не админ,   |{"delete": true}| -  |
| /api/login | GET | Вход в приложением  | нет | нет| - |  [{“id”:4, “logged”:true}  | **login** - ваш email, **password** - пароль |
| /api/reset_password | GET | Присылает новый сгенерированный пароль на почту которую вы указали как login   | нет | нет| - |  [{“send”:true, “message”:"Сообщение у вас не почте!"}  | **email** - ваш login |
| /api/logout | GET | Выйти из приложения  | да | нет| - |  [{“exit”:true }  | - |
| /api/admin/user | GET | Список пользователей  | да | да | Присылает данные всех зарегистрированных пользователей |  [{"id":1, "login":qwer@qwer.ru, "role":"user", "root_directory_id":2}б {"id":3, "login":admin@admin.ru, "role":"admin", "root_directory_id":2}]  | - |
| /api/admin/user/{id}| GET | Отправляет JSON файл с инфорцией о пользователе | да | да| -  |[{"id":3, "login":qwer@qwer.ru, "role":"user", "root_directory_id":2}] |- |
| /api/admin/user/{id}| DELETE | Удаляет пользователя | да | да | -  |{"delete": true} |- |
| /api/admin/user/ | PUT | Обновляет данные о любом пользователе  | да | да | -  |{"updated": true}| **login** - какой то email, **password** - пароль, **role** - user или  admin, **id** - пользователя которого вы обновляете  |
| /api/file | GET | Получить список данных о всех своих файлах (директория в которой они хранятся, id, название файла, пусть до директории ) | да | нет | -  | [{"file_id":2, "pwd":"/test/", "file_name":"file.txt", "directory_id":3  }, {"file_id":4, "pwd":"/test/childtest/", "file_name":"file-2.txt", "directory_id":5  }] |- |
| /api/file/{id} | GET | Получить данные о файле по id | да | нет | файл должен принадлежать вам  | [{"file_id":2, "pwd":"/test/", "file_name":"file.txt", "directory_id":3  }, {"file_id":4, "pwd":"/test/childtest/", "file_name":"file-2.txt", "directory_id":5  }] | - |
| /api/file/ | POST | Создать файл | да | нет | формат отправлки form-data  |{"created_file": "файл успешно создан", "id":4}|** file **- файл который вы отправляете ( не более 2 гб), **dir_id **- айди директории в которой будет хранится файл  |
| /api/file | PUT | переименовать файл или переместить его в другую директорию | да | нет | - |{"edit_file": true}|**id **- id файла , name - новое название файла, **dir_id** - айди другой директории в которой будет хранится файл  |
| /api/file/{id} | DELETE | Удалить файл | да | нет | - |{"delete": true}|-  |
| /api/directory | POST | Создать директорию | да | нет | - |{"created": true, "pwd":"/test/newdir/", id:6 }| **name **- название директории, **parent_dir_id** - айди диретории для хранения |
| /api/directory | PUT | Переименовать директорию | да | нет | - |{"created": true, "pwd":"/test/newdir/", id:6 }| **id **- директории , **name** - новое название директории |
| /api/directory | PUT | Переименовать директорию | да | нет | - |{"edit_dir": true}| **id **- директории , **name** - новое название директории |
| /api/directory/{id} | GET | Информация о директории, дочерние директории , дочерние файлы, айди директории, айди владельца и родительская директория  | да | нет |директория должна принадлежать авторизованному пользователю |{"id":1, "pwd":"/test/", "owner":33, "files":["test.png", "test.jpg"], "children_dirs":["/test/test2/", "/test/test3/"]} | - |
| /api/directory/{id}| DELETE | Удалить директорию | да | нет | - |{"delete": true}  | -|
| /api/user/search/{email} | GET | Информация о пользователе по email/login | да | нет | Получить информацию можно о любом пользователе  |{"id": 3, "login":"user@user.ru"}  |  -|
| /api/files/share/{id}/{user_id} | PUT | Поделиться файлом для скачивания | да | нет |-|{"share": true, "link_to_download" : "/share_file/4", "id_share":4}  |  -|
| /api/files/share/{id} | GET | Получить инфомарция о файле, кто может скачать и по какой ссылке | да | нет | Нужно быть владельцем файла |[{"user_id": 3, "share_path" : "/share_file/32", "user_login":admin@admin.ru}, {"user_id": 4, "share_path" : "/share_file/35", "user_login":user@qwerty.ru}]  |  -|
| /api/files/share/{id}/{user_id}| DELETE | Запретить скачивать файл для определенного юзера  | да | нет | - |{"delete": true}  | -|
| / | GET | Получить главную страницу html  | нет | нет | - | index.html | -|
| /share_file/{id} | GET | Получить файл которым поделились  | да | нет | нужно быть или владельцем файла или тем, с кем файлом поделились | файл для скачивания | -|
| /download/{id}' | GET | Скачать свой файл, вместо id указать просто id файла  | да | нет | нужно быть или владельцем файла  | файл для скачивания | -|

Теперь краткая навигация по сущностям проекта:
В папке /src/app/Errors хранятся кастомные ошибка, в частности:
* src/app/Errors/DataBaseException.php - для вывода ошибок при работе с базой данных 
* src/app/Errors/EmailException.php - для вывода ошибок при работе с рассылкой email
* src/app/Errors/FileStorageException.php - для вывода ошибок при работе с файловой системой

В папке  src/app/Custom как я писал  лежат классы для работы непосредственно данного приложения

###### Email

Данный класс имеет только один метод send, который принимает 4 аргумента:
1. от кого будет отправлено сообщение - название организации, имя человека
2.  email адрес получателя
3.  тема письма
4.   текст сообщения в формате html
Пример:
```
Email::send(
				'my_fyles',
				test@test.ru,
				'Запрос на смену пароля',
				"<h1>Cброс пароля</h1>
				<p>Ваш новый пароль - <b>$newPass</b></p>
				<p>Поменять данный пароль вы сможете в личном кабинете после входа!</p>
				<p>Если вы не делали запрос, проигнорируйте это письмо!</p>"
);
```
В случае неудаче отдает ошибку  EmailException.

###### DataBase

Класс по сути надстройка над строенным классом PDO, осуществляет в конструкторе  подключение к MySQL.  Реализован паттерном [синглтон](https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D1%87%D0%BA%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F) "синглтон").   Имеет два методы:

| Название метода  | Что делает  | 
| -------------- | ------------- |
|```public static function create()``` | Создает новое подключение к базе данных|
|```public function lastRowID()``` | Возвращает id последней созданной записи в бд |
|```public function quary()``` | Выполняет запрос в базу данных, первый аргумент текст sql запроса, второй аргументы. ДЛЯ ТРАНЗАЦИЙ НЕ ИСПОЛЬЗОВАТЬ! В случае ошибки не выкидывает ошибку, а просто возвращает массив ```['success'=>false]``` и записывает ошибку в лог в файл storage/logs/db.log|
|```public function quaryTransaction()``` | аналогичен методу выше, но выкидывает ошибку в случае неудачи , лучше использовать для тразакций|
|```public function startTransaction()``` | Начало транзакции |
|```public function  acceptTransaction()``` | Окончания транзакции как успешной |
|```public function  acceptTransaction()``` | Окончания транзакции как провальной и отмена изменений в бд |

В случае ошибки выкидывает DataBaseException.

###### Crypter
Класс нужен для шифрования данных в паролях

| Название метода  | Что делает  | 
| -------------- | ------------- |
|```public static function crypt(string $str)``` | Получение хэша пароля |
|```public static function verify(string $str, string $pass_hash)``` | Сравнение строки с хэшем пароля, в случае успеха пароль верен |
|```public function  encodeID``` | Кодирует string с base64. |

###### FileStorage

По сути главный класс для работы с файловым хранилищем.
Перед описание методов, важно рассказать вообще о принципе работы с файлами в приложение
Файлы сохраняются в папку /storage/filestorage, сохраняется файл по принципу id_file.txt, id берется из таблицы files, так что все названия будут уникальны, что позволяет не дублировать папки пользователя , а держать их лишь номинально в бд. 


| Название метода  | Что делает  |
| -------------- | ------------- |
|```renameFile```| Переименовывает файл в папке по названию и id  |
|``` addFile``` | Добавляет новый файл в /storage/filestorage , принимает массив в котором должен быть путь до файла во временном хранилище ['tmp'] и  название файла ['name'], вторым аргументом принимает уникальный id|
|```deleteFile``` | Удаляет файл по id и названию |
|```deleteFileAll``` | Удаляет файлы по id и названию, принимает массива типо [['id'=>3, 'name'=>'test.txt'], ['id'=>4, 'name'=>'test2.txt']] |
|```getAllFileRecursive``` | Получает названия  id всех файлов в папке  и подпапках рекурсивно   |
|```sendFile``` | Отправляет файл на клиент для скачивания по id и названию   |

В случае ошибки выкидывает FileStorageException.

#### Контроллеры и мидлверы
В приложении 3 контроллера:
1. User - отвечает за все ответ по пользователям
2. File - отвечает на запросы связанные с файловой системой
3. Pages - отвечает на запросы страниц (одни метод index, в котором отдает главную страницу)

Все мидверы хранятся в папке src/app/Controllers/Middlewares  и разложены по соответсвующим папкам: 
* src/app/Controllers/Middlewares/DirectoryMiddlewares - Мидверы связанные с запросами по директориям (в основном это валидация )
* src/app/Controllers/Middlewares/FilesMiddlewares - Мидверы связанные с запросами по файлам (в основном это валидация )
* src/app/Controllers/Middlewares/ShareMiddlewares - Мидверы связанные с запросами по шерингу файлов (в основном это валидация )
* src/app/Controllers/Middlewares/UserMiddlewares- Мидверы связанные с запросами по пользователям  (в основном это валидация )

Базу данныз для приложения можно получить из дамп файла - MyFiles.sql

Спасибо за внимание, надеюсь работа с приложением и фреймвороком будет для вас комфортна,
С уважением, Стриго Александр!
Телеграм -  [@Alex_Strigo](https://t.me/Alex_Strigo "@Alex_Strigo")